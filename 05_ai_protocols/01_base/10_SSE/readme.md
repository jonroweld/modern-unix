# Server-Sent Events (SSE) for Model Context Protocol (MCP)

Server-Sent Events (SSE) is a standard that enables servers to push real-time updates to clients over a single, long-lived HTTP connection. In the context of the Model Context Protocol (MCP), SSE (often referred to as "HTTP with SSE") has been a standard transport mechanism for communication between MCP clients and remote MCP servers, particularly before the introduction of the newer "Streamable HTTP" transport.

This document focuses on the classic implementation of SSE as an MCP transport, typically involving distinct endpoints for connection establishment and message exchange.

---

## Classic MCP SSE Transport: Conceptual Overview

The traditional MCP transport using HTTP with SSE generally follows this pattern (as described in resources like ["MCP Server and Client with SSE & The New Streamable HTTP!"](https://medium.com/@itsuki.enjoy/mcp-server-and-client-with-sse-the-new-streamable-http-d860850d9d9d)):

1.  **Connection Endpoint (`GET` Request)**:
    - The MCP client initiates a connection by sending an HTTP `GET` request to a dedicated SSE connection endpoint on the MCP server (e.g., `/connect`, `/events`, or `/mcp` as seen in some examples).
    - The server responds by establishing an SSE stream (`Content-Type: text/event-stream`).
2.  **Endpoint Event (Server-to-Client)**:
    - Upon successful connection, the MCP server often sends an initial "endpoint event" message over the SSE stream. This event typically contains the relative URI of the messaging endpoint that the client should use for sending its JSON-RPC messages to the server.
3.  **Messaging Endpoint (`POST` Request)**:
    - The MCP client sends its JSON-RPC messages (e.g., `tools/list`, `tools/call`) to the server using HTTP `POST` requests to the messaging endpoint URI provided in the endpoint event.
    - The MCP server processes these requests and sends responses or notifications back to the client over the established SSE stream.
4.  **Session ID Management**: To support multiple simultaneous connections, a `sessionId` is often used. This ID might be generated by the server and associated with the transport, and the client might need to include it in its `POST` requests (e.g., as a query parameter) to ensure messages are routed to the correct session.
5.  **JSON-RPC Payloads**: All application-level messages (client-to-server requests, server-to-client responses, and server-initiated notifications) are encoded as JSON-RPC 2.0 objects.

---

## Working with Classic MCP SSE in Python

While the newer "Streamable HTTP" transport for MCP aims to simplify this, understanding the classic SSE flow is important. Python libraries like `FastAPI` and `httpx` can be used to implement this.

### Example 1: Conceptual Classic MCP SSE Server (FastAPI)

This example illustrates the two-endpoint model for MCP over SSE.

```python
from fastapi import FastAPI, Request, Query
from fastapi.responses import StreamingResponse
import asyncio
import json
import uuid

app = FastAPI()

# In-memory store for active client streams and their messaging endpoints
# Key: session_id, Value: SSE transport (conceptual)
active_mcp_transports = {}

MESSAGING_ENDPOINT_PATH = "/mcp_messages" # Relative path for POSTing messages

async def sse_mcp_stream_generator(session_id: str, base_url: str):
    # 1. Send the endpoint event immediately after connection
    messaging_uri = f"{base_url.rstrip('/')}{MESSAGING_ENDPOINT_PATH}?sessionId={session_id}"
    endpoint_event_data = {
        "jsonrpc": "2.0",
        "method": "mcp/endpoint", # Conceptual method name
        "params": {"messaging_uri": messaging_uri}
    }
    yield f"data: {json.dumps(endpoint_event_data)}\n\n"
    print(f"[{session_id}] Sent endpoint event: {messaging_uri}")

    # 2. Keep stream open for server-to-client messages (notifications, responses)
    try:
        count = 0
        while True:
            if session_id not in active_mcp_transports:
                break # Stop if session is removed

            # Simulate sending a server notification (JSON-RPC format)
            notification_data = {
                "jsonrpc": "2.0",
                "method": "notifications/message",
                "params": {"level": "info", "data": f"Server heartbeart {count} for {session_id}"}
            }
            yield f"data: {json.dumps(notification_data)}\n\n"
            count += 1
            await asyncio.sleep(5) # Send heartbeat every 5 seconds
    except asyncio.CancelledError:
        print(f"[{session_id}] Stream cancelled.")
    finally:
        if session_id in active_mcp_transports:
            del active_mcp_transports[session_id]
        print(f"[{session_id}] SSE stream closed.")

@app.get("/mcp_connect")  # Connection endpoint
async def mcp_connect(request: Request):
    session_id = str(uuid.uuid4())
    active_mcp_transports[session_id] = {"status": "connected"} # Simplified transport representation
    print(f"Client connected with session_id: {session_id}")

    # Determine base_url for constructing full messaging_uri
    # This is a simplification; robust URL construction is needed in production
    base_url = str(request.base_url)

    return StreamingResponse(
        sse_mcp_stream_generator(session_id, base_url),
        media_type="text/event-stream"
    )

@app.post(MESSAGING_ENDPOINT_PATH)  # Messaging endpoint
async def mcp_messages(request: Request, sessionId: str = Query(...)):
    if sessionId not in active_mcp_transports:
        return {"jsonrpc": "2.0", "error": {"code": -32000, "message": "Invalid or expired session ID"}, "id": None}

    try:
        mcp_payload = await request.json()
        print(f"[{sessionId}] Received MCP message: {mcp_payload}")

        # Process the MCP JSON-RPC message (e.g., tool_call, list_tools)
        # The actual response would typically be sent over the SSE stream,
        # or if it's a direct response to a request with an ID, it might be part of this POST response.
        # For simplicity, this example returns a direct HTTP response.
        # In a full MCP implementation, you'd correlate this with the SSE stream.

        # Simulate processing and preparing a response
        response_data = {
            "message": "MCP message received by server (simulated direct response)",
            "original_payload": mcp_payload
        }

        # Example: If it was a request expecting a direct result with an ID
        if "id" in mcp_payload:
            return {"jsonrpc": "2.0", "result": response_data, "id": mcp_payload["id"]}
        else:
            # For notifications or requests not expecting immediate HTTP response
            return {"jsonrpc": "2.0", "result": {"message": "Notification processed"}, "id": None} # Or just 204 No Content

    except json.JSONDecodeError:
        return {"jsonrpc": "2.0", "error": {"code": -32700, "message": "Parse error"}, "id": None}
    except Exception as e:
        print(f"Error processing message: {e}")
        return {"jsonrpc": "2.0", "error": {"code": -32000, "message": f"Server error: {e}"}, "id": None}

# To run (save as classic_mcp_sse_server.py):
# uvicorn classic_mcp_sse_server:app --reload
```

### Example 2: Conceptual Classic MCP SSE Client (httpx)

```python
import httpx
import asyncio
import json

CONNECTION_URL = "http://127.0.0.1:8000/mcp_connect"
messaging_uri_from_server = None
mcp_session_id = None

async def consume_classic_mcp_sse_stream():
    global messaging_uri_from_server, mcp_session_id
    print("--- Client: Connecting to MCP SSE endpoint... ---")
    try:
        async with httpx.AsyncClient(timeout=None) as client:
            async with client.stream("GET", CONNECTION_URL) as response:
                print(f"--- Client: SSE Connection Status: {response.status_code} ---")
                response.raise_for_status()
                async for line in response.aiter_lines():
                    if line.startswith("data:"):
                        try:
                            payload_str = line[len("data:"):]
                            data = json.loads(payload_str)
                            print(f"Client received SSE data: {data}")

                            # Check for the initial endpoint event
                            if data.get("method") == "mcp/endpoint" and "params" in data and "messaging_uri" in data["params"]:
                                messaging_uri_from_server = data["params"]["messaging_uri"]
                                # Extract session ID from the messaging URI (simple parsing)
                                if "?sessionId=" in messaging_uri_from_server:
                                    mcp_session_id = messaging_uri_from_server.split("?sessionId=")[-1]
                                print(f"Client: Received messaging URI: {messaging_uri_from_server}")
                                print(f"Client: Extracted Session ID: {mcp_session_id}")
                        except json.JSONDecodeError:
                            print(f"Client received non-JSON SSE data: {line}")
                    elif line:
                        print(f"Client received SSE metadata: {line}")
    except httpx.RequestError as e:
        print(f"--- Client: Error connecting/streaming: {e} ---")
    except Exception as e:
        print(f"--- Client: An unexpected error occurred during streaming: {e} ---")

async def send_mcp_message_via_post(payload: dict):
    if not messaging_uri_from_server:
        print("--- Client: Messaging URI not yet received from server. Cannot send POST. ---")
        return

    print(f"\n--- Client: Sending MCP message to {messaging_uri_from_server} via POST ---")
    try:
        async with httpx.AsyncClient() as client:
            # The messaging_uri_from_server already contains the sessionId query param from the server example
            response = await client.post(messaging_uri_from_server, json=payload)
            response.raise_for_status()
            print(f"Client POST response: {response.json()}")
    except httpx.RequestError as e:
        print(f"Client POST error: {e}")
    except json.JSONDecodeError:
        print(f"Client POST response (not JSON): {response.text}")

async def main():
    stream_task = asyncio.create_task(consume_classic_mcp_sse_stream())

    # Wait for the messaging URI to be received
    for _ in range(10): # Wait up to 5 seconds
        if messaging_uri_from_server and mcp_session_id:
            break
        await asyncio.sleep(0.5)

    if messaging_uri_from_server and mcp_session_id:
        tool_call = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {"name": "my_tool", "arguments": {}},
            "id": "client-req-001"
        }
        await send_mcp_message_via_post(tool_call)
    else:
        print("--- Client: Failed to get messaging URI or session ID from server. ---")

    await asyncio.sleep(10) # Keep stream alive for a bit
    stream_task.cancel()
    try:
        await stream_task
    except asyncio.CancelledError:
        print("--- Client: SSE stream task cancelled by main. ---")

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Key Characteristics (Recap for MCP Classic SSE)

- **Unidirectional Stream:** The SSE connection is primarily for server-to-client data push.
- **Separate Messaging Channel:** Client-to-server messages typically use a separate HTTP POST request to a different endpoint.
- **`text/event-stream`:** The SSE stream uses this specific media type.
- **Automatic Reconnection (Client-Side):** Standard browser `EventSource` APIs handle reconnection automatically. Custom clients (like `httpx`) need to implement this logic if desired.
- **JSON-RPC Payloads:** All MCP communication (requests, responses, notifications) is structured as JSON-RPC messages.

## Strengths (in MCP Context)

- **Well-Understood:** SSE is a mature W3C standard, and its use in MCP has been established.
- **HTTP-Based:** Works over standard HTTP/1.1 and HTTP/2, leveraging existing web infrastructure.
- **Good for Notifications:** Excellent for server-initiated updates, logs, and partial results from agents or tools.

## Weaknesses/Considerations (in MCP Context)

- **Two-Endpoint Complexity**: Managing two separate endpoints (one for SSE, one for POST messages) can add complexity to server and client implementations compared to single-endpoint approaches.
- **Coordination**: Requires coordination between the SSE stream and the POST messaging channel, often using session IDs.
- **Authentication**: As noted in the Medium article by Itsuki, handling authentication securely for remote MCP servers using this transport can be challenging, as standard SSE browser APIs have limitations with custom headers for the SSE connection itself.
- **Proxy/Firewall Issues**: SSE can sometimes be problematic with intermediaries that might buffer or not correctly handle `text/event-stream`.

## Use Cases in DACA (Agentic AI Systems)

- **Live Dashboards & Monitoring**: Streaming agent status, metrics, or logs to a UI.
- **Real-time Notifications**: Pushing alerts or updates from agents to users or other systems.
- **Streaming Partial Results**: Agents or tools can stream intermediate results or progress updates over SSE before a final response is ready (which might be delivered via SSE or in response to a POST).

## Place in the Protocol Stack

- **Layer**: Application Layer (OSI Layer 7) - as an MCP transport.
- **Above**: MCP SDKs, Agent Frameworks.
- **Below**: HTTP/1.1, HTTP/2.

---

## Further Reading

- [MCP Server and Client with SSE & The New Streamable HTTP!](https://medium.com/@itsuki.enjoy/mcp-server-and-client-with-sse-the-new-streamable-http-d860850d9d9d) (Provides context on this classic SSE transport for MCP).
- [MDN: Server-Sent Events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events)
- [FastAPI StreamingResponse](https://fastapi.tiangolo.com/advanced/custom-response/#streamingresponse)
- [HTML Living Standard: Server-sent events](https://html.spec.whatwg.org/multipage/server-sent-events.html)
